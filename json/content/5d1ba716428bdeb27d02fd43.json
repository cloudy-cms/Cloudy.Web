{
  "_id": { "$oid": "5d1ba716428bdeb27d02fd43" },
  "Id": "4176df16-aa47-4607-ace5-30f76c01d123",
  "GlobalFacet": {
    "Language": "*",
    "Interfaces": {
      "IContent": {
        "Id": "IContent",
        "Properties": {
          "Id": "4176df16-aa47-4607-ace5-30f76c01d123",
          "ContentTypeId": "b5417718-81a3-4d06-a5d7-c6b8b40915df"
        }
      },
      "IRoutable": {
        "Id": "IRoutable",
        "Properties": { "UrlSegment": "declarative-routing-in-asp-net-core-2-2" }
      },
      "IHierarchical": {
        "Id": "IHierarchical",
        "Properties": { "ParentId": null }
      }
    },
    "Properties": {
      "Name": "Declarative routing in ASP.NET Core 2.2",
      "Text": "<p>In web development, routing refers to the mechanism by which an HTTP request is matched to its respective request handler (in our case, the MVC handler executing a matching controller action).</p>\n\n<p>The word “route” actually has two distinct pronunciations, “rowt” and “root”, meaning “way” or the closely related and phonetically similar “road”. In other words, routing means “finding the (correct) way”.</p>\n\n<h2>Routes vs. Routers</h2>\n<p>ASP.NET routes are set up declaratively using a string template (which is also called a pattern), which are then dynamically matched against each request path. The part responsible for actually routing the requests, the router middleware (RouterMiddleware), knows only about routers (anything implementing IRouter.RouteAsync), not routes. Declarative routes may be considered anything inheriting from the abstract class RouteBase, but most probably you will only deal with declarative routes, either directly or indirectly, through the concrete implementation Route.</p>\n\n<p>That means ASP.NET routing is actually done imperatively, not declaratively. Through the IRouter.RouteAsync interface the logic of the routing is inside each router. Because of this, an IRouter may implement declarative routing conventions, but is by no means limited to. This means that each route, even the declarative routes, are responsible for matching themselves to a request. There isn’t any supermatcher that you need to configure to adjust the matching logic; you simply need to change the logic of your own route(r).</p>\n\n<p>A common misconception (that was historically true) is that Routing is tied to MVC. This is no longer the case. In the case of ASP.NET Core MVC, the resolving of the controller action is done within the MVC Route handler (a simple async httpContext => … delegate) and is thus easily bypassed.\nIf you would like to use declarative routing but still execute arbitrary code, outside of MVC, you can create a Route and supply (non-obviously) an IRouter instance that sets the RouteContext.Handler member. For that you can use the RouteHandler class, or simply use the following handy extension method:</p>\n\n<pre>app.UseRouter(r => r.MapRoute(\"hello-world\", async c => await c.Response.WriteAsync($\"Lorem ipsum {c.Request.Path}\")));</pre>\n\n<p>This way you can still make use of the nice features declarative routing provides, like routing constraints and catch-all route segments, while avoiding the controller (etc) constructs of MVC.</p>\n\n<p>We will only really consider declarative routes inheriting from RouteBase in this article, and not other types of routing like attribute routes (which implements IRouter directly). We will also assume that you are using MVC, even though most of the information is not specific to it.</p>\n\n<p>Routers can choose to implement INamedRouter, which gives them a Name that can be helpful when troubleshooting. The name can still be null (or an empty string!) though and will in that case not be validated for uniqueness.</p>\n\n<h2>Route collections</h2>\n<p>A route collection is essentially an IRouter that contains a list of routes, calling RouteAsync on each one until one of them sets the RouteContext.Handler member to something not null.</p>\n\n<p>This is a way to encapsulate the “try … next” logic that would otherwise have been located in the RouterMiddleware. Instead, the RouterMiddleware calls a single root-level route collection containing all different routes, which then goes through them all in a performant manner.</p>\n\n<p>Furthermore, as the route collection itself implements IRouter, and it contains a list of IRouter, they can be nested several levels deep. This can be beneficial in order to group (and order) routes logically, if they only could be named …</p>\n\n<p>Route collections also have the benefit of guaranteeing route name uniqueness within a single collection. Routes nested in other route collections are not checked.</p>\n\n<h2>Parsing</h2>\n<p>In the route’s constructor, the route template (or pattern) is parsed into a sequence of pattern segments. Each segment is separated by a slash. A pattern segment cannot contain a slash.</p>\n\n<p>Segments consist of parts. Simple segments contain only a single part, which would be the most common scenario, and complex segments contain several parts.</p>\n\n<p>Furthermore, segment parts (RoutePatternPart) are either literals (meaning they literally must be equal to that string in order to match) or parameters (meaning they can be any string, as long as their constraints are satisfied).</p>\n\n<p>Optional segments (that is, simple segments containing an optional parameter) are segments at the end of the pattern, which may be left out and even be assigned a default value. If the segment is left out the slash separating it from the previous segments can be left out as well. There is no such thing as an optional literal segment.</p>\n\n<p>Complex segments may also end with an optional file extension parameter, such as “download/{name}.{extension?}”. In that case, the last segment ({name}.{extension?}) contains three parts, where the first is a parameter named “name”, the second one is a separator (not a literal) (“.”), and the last one is an optional parameter named “extension”. Other uses of the separator part (let’s say you thought that the path segment part separator could ever be a slash) is not allowed or possible.</p>\n\n<p>Some very specific implementation details follows here: The dot (“.”) is regarded as a separator only in this case, that is when succeeded by an optional final parameter, and preceded either by a non-optional parameter (“{name}.{extension?}”) or by nothing (“.{extension?}”). The last part is allowed in my opinion only because an oversight by the developers, because it wouldn’t be very useful and it doesn’t get caught during the actual matching. Chrome refuses to even send the request without first removing the dot (ie. navigating to something like http://foo.com/. with a final dot after the slash), and using some other tool for sending the request yields a 404.</p>\n\n<p>A simple parameter segment can be a catch-all (the name is then prefixed by an asterisk), which means that it will catch everything remaining of the path, if any. It may be an empty string as well. A catch-all parameter cannot be part of a complex segment, nor can it be marked as optional (if left out, it will be set to an empty string).</p>\n\n<h2>Matching</h2>\n<p>In the ASP.NET source code for matching, the request URL (minus the domain part) is usually referred to as “the path”. The route templates are referred to as “patterns” (and sometimes also “pattern paths”).</p>\n\n<p>Remember that a route does its own matching - nothing does the matching for the route without its knowledge, and the matching logic is done within the route itself.</p>\n\n<p>The first route that matches the path will be the one selected. Subsequent routes won’t even be evaluated.\nRoute matching takes place in several passes.</p>\n\n<p>The first pass is a simplistic one; it entails simply checking the path for the existence of a corresponding segment, while making sure the simple segment literals match. For parameters, the path segments are simply checked to be non-empty.</p>\n\n<p>After all segments of the path is checked, either the end of the pattern must have been reached, or only optional segments remain (or a catch-all, which will then be empty).</p>\n\n<p>The second pass involves actually populating the route values from the path. We also validate the complex segments, which is a bit more involved than just comparing strings, and thus it was moved to the second pass. (so it could bail early)</p>\n\n<p>After all path parameters have been captured, the pattern may contain parameter segments not existent in the path. Because of the first pass, these are guaranteed to be either optional parameters, or parameters with a default value. Those default values are also inserted as route values.</p>\n\n<h2>Constraint resolving</h2>\n<p>If any of the parameters have inline constraints defined (done by suffixing the parameter names with colon (“:”) and then the constraint name), these are checked now. If any of them fail, the route will not match. Remaining constraints will not be checked.</p>\n\n<p>Constraints also have the opportunity to set route values. Although in most cases this wouldn’t be a good idea, when doing database queries based on route values it would perhaps make sense to cache their results in some way ahead of model binding, where the result for the same query would be required.</p>\n\n<h2>Handling</h2>\n<p>You will in all probability be using the concrete Route class implementation of RouteBase. So here’s the cryptic part:</p>\n\n<p>The Route class accepts a “target” parameter in its constructor, which is itself an IRouter. That “target” is responsible for setting the RouteContext.Handler member to a non-null RequestDelegate, in other words a lambda which receives a HttpContext as parameter.</p>\n\n<p>An IRouter implementation is expected to set the RouteContext.Handler delegate if its RouteAsync is successful. So why in the world does an IRouter implementation accept an IRouter implementation to set its handler for it? There’s even a RouteHandler class which accepts a RequestDelegate lambda, and implements IRouter, only to set it the RouteContext.Handler during its RouteAsync.</p>\n\n<p>Strange times! Perhaps it is to track which class actually set the handler, which is done in RouteContext.RouteData.Routers, but this benefit seems a bit weak to merit such a strange setup.</p>"
    }
  },
  "LanguageFacets": {}
}
